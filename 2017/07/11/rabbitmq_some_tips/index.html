<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RabbitMQ 的一点参考 · Rust.Love</title><meta name="description" content="RabbitMQ 的一点参考 - OutMan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://rust.love/atom.xml" title="Rust.Love"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">RabbitMQ 的一点参考</h1><div class="post-info">Jul 11, 2017</div><div class="post-content"><h2 id="三个概念">三个概念</h2><h3 id="Exchange">Exchange</h3><h3 id="Channel">Channel</h3><h3 id="Queue">Queue</h3><p>客户端和服务建立连接，通过 Channel 向 Exchange 发送消息，Exchange 通过 Routing<br>Key 将消息路由到 Queue （Exchange 和 Queue 通过 Routing Key<br>建立绑定关系，Routing Key 也可以为空）.</p>
<h2 id="Exchange_三个类型">Exchange 三个类型</h2><h3 id="fanout">fanout</h3><h3 id="direct">direct</h3><h3 id="topic">topic</h3><ul>
<li>fanout 简单的来说是广播模式，即 Exchange<br>会把消息广播给所有和他绑定的队列，使用场景多个业务线需要使用同一份数据，每个业务线可以建立一个<br>Queue，这样通过广播的形式把同一条消息发给每个队列。</li>
<li>direct 从字面来理解是直接发送，即 Exchange 会通过 Routing Key 把消息路由到指定的队列，目前我们的使用场景是 APP 上传日志，通过一个 Exchange 路由到 5 个 Queue，这样可以有 5 个消费者来消费，因为日之内有时间戳，所以对时序无要求。单纯的对一个队列增加消费者，是没办法直接提高消费速度的。</li>
<li>topic 可以通过通配符（正则表达式）Routing Key 来把消息路由到 Queue，目前我们没有使用这种模式。</li>
</ul>
<h2 id="两个参数">两个参数</h2><h3 id="durable">durable</h3><h3 id="delivery_mode">delivery_mode</h3><ul>
<li>durable Exchange 是否持久化</li>
<li>delivery_mode publish 消息时是否持久化</li>
</ul>
<p>durable 和 delivery_mode<br>是必须要一致的才会生效，持久化消息服务重启不会丢失消息，而非持久化模式性能大约会提高<br>10 倍（数据来自网络，没亲测）。</p>
<h3 id="关于_Exchange_、Queue_的建立和绑定">关于 Exchange 、Queue 的建立和绑定</h3><p>客户端在和服务端建立连接以后，会通过客户端提供的 <strong><em>*_declare<br>方法来创建，Exchange 和 Queue，通过 </em></strong>_bind 方法来绑定 Exchange 和 Queue，如果<br>Exchange 和 Queue 已经存在，则忽略，否则会创建。在创建时，会指定一些基础参数例如<br>durable，routing key 等，durable 要和 publish 消息是的 delivery_mode 一致。</p>
<h3 id="consumer_utilisation">consumer_utilisation</h3><p>如果值比较低有以下几种可能，消费者太多（少），ACK 应答慢。</p>
<h3 id="prefetch">prefetch</h3><p>可以影响效率，官方文档有个表格。</p>
<h3 id="frame_max">frame_max</h3><p>服务端参数，影响吞吐率和延迟</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/01/29/some_git_tils/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://rust.love">OutMan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>