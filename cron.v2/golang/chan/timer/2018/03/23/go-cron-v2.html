<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>通过项目来学习 Golang 之 cron.v2 源码分析（一周学习报-第 6 期） | Rust.Love</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="通过项目来学习 Golang 之 cron.v2 源码分析（一周学习报-第 6 期）" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="根据第五期的 cron 项目，理解 cron.v2 项目的源码，主要涉及的知识点" />
<meta property="og:description" content="根据第五期的 cron 项目，理解 cron.v2 项目的源码，主要涉及的知识点" />
<link rel="canonical" href="http://rust.love/cron.v2/golang/chan/timer/2018/03/23/go-cron-v2.html" />
<meta property="og:url" content="http://rust.love/cron.v2/golang/chan/timer/2018/03/23/go-cron-v2.html" />
<meta property="og:site_name" content="Rust.Love" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-03-23T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"根据第五期的 cron 项目，理解 cron.v2 项目的源码，主要涉及的知识点","@type":"BlogPosting","url":"http://rust.love/cron.v2/golang/chan/timer/2018/03/23/go-cron-v2.html","headline":"通过项目来学习 Golang 之 cron.v2 源码分析（一周学习报-第 6 期）","dateModified":"2018-03-23T00:00:00+08:00","datePublished":"2018-03-23T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://rust.love/cron.v2/golang/chan/timer/2018/03/23/go-cron-v2.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/main.css">
  <link type="application/atom+xml" rel="alternate" href="http://rust.love/feed.xml" title="Rust.Love" />
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" rel="author" href="/">Rust.Love</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">通过项目来学习 Golang 之 cron.v2 源码分析（一周学习报-第 6 期）</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-03-23T00:00:00+08:00" itemprop="datePublished">
        
        Mar 23, 2018
      </time>
      </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>根据<a href="http://rust.love/golang/gin-gonic/crontab/2018/03/09/golang-crontab-web.html">第五期</a>的 cron 项目，理解 cron.v2 项目的源码，主要涉及的知识点</p>

<ul>
  <li>go 关键字</li>
  <li>chan select</li>
  <li>闭包</li>
  <li>接口</li>
</ul>

<p>先看下源码的结构</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>├── LICENSE
├── README.md
├── constantdelay.go 处理特殊时间格式 struct
├── cron.go 负责整个流程控制和调度的 struct
├── doc.go 文档文件
├── parser.go 将输入的 crontab 格式进行转换
└── spec.go Schedule 数据定义和转换
</code></pre></div></div>

<p>整个代码的执行流程</p>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        NewCron<span class="o">()</span>
          ⇊
Add<span class="o">(</span>Schedule, Command<span class="o">)</span>
          ⇊
    Parse<span class="o">(</span>Schedule<span class="o">)</span>
          ⇊
         Run<span class="o">()</span>
</code></pre></div></div>

<p>主要的相关的源码 <strong><em>cron.go</em></strong></p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">Cron</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">entries</span><span class="x">  </span><span class="p">[]</span><span class="o">*</span><span class="n">Entry</span><span class="x"> </span><span class="c">// 一个任务，就是一个 entry</span><span class="x">
    </span><span class="n">stop</span><span class="x">     </span><span class="k">chan</span><span class="x"> </span><span class="k">struct</span><span class="p">{}</span><span class="x"> </span><span class="c">// 停止任务</span><span class="x">
    </span><span class="n">add</span><span class="x">      </span><span class="k">chan</span><span class="x"> </span><span class="o">*</span><span class="n">Entry</span><span class="x"> </span><span class="c">// 添加任务</span><span class="x">
    </span><span class="n">remove</span><span class="x">   </span><span class="k">chan</span><span class="x"> </span><span class="n">EntryID</span><span class="x"> </span><span class="c">// 移除任务，每个 Entry 都有一个 ID，稍后介绍</span><span class="x">
    </span><span class="n">snapshot</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="p">[]</span><span class="n">Entry</span><span class="x"> </span><span class="c">// 当前任务</span><span class="x">
    </span><span class="n">running</span><span class="x">  </span><span class="kt">bool</span><span class="x"> </span><span class="c">// 整个 Cron 是否处于运行状态</span><span class="x">
    </span><span class="n">nextID</span><span class="x">   </span><span class="n">EntryID</span><span class="x"> </span><span class="c">// 下一个 Entry</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// 一个具体的任务</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">Entry</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// ID is the cron-assigned ID of this entry, which may be used to look up a</span><span class="x">
    </span><span class="c">// snapshot or remove it.</span><span class="x">
    </span><span class="n">ID</span><span class="x"> </span><span class="n">EntryID</span><span class="x">

    </span><span class="c">// Schedule on which this job should be run.</span><span class="x">
    </span><span class="n">Schedule</span><span class="x"> </span><span class="n">Schedule</span><span class="x">

    </span><span class="c">// Next time the job will run, or the zero time if Cron has not been</span><span class="x">
    </span><span class="c">// started or this entry's schedule is unsatisfiable</span><span class="x">
    </span><span class="n">Next</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="x">

    </span><span class="c">// Prev is the last time this job was run, or the zero time if never.</span><span class="x">
    </span><span class="n">Prev</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="x">

    </span><span class="c">// Job is the thing to run when the Schedule is activated.</span><span class="x">
    </span><span class="n">Job</span><span class="x"> </span><span class="n">Job</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>上面的 Entry 里面有两个 struct，我们先来看一下 <strong><em>Schedule</em></strong>，Schedule 是一个 interface，主要是描述了一个 Job 具体运行的时间</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// 一个接口</span><span class="x">
</span><span class="c">// Schedule describes a job's duty cycle.</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">Schedule</span><span class="x"> </span><span class="k">interface</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// Next returns the next activation time, later than the given time.</span><span class="x">
    </span><span class="c">// Next is invoked initially, and then each time the job is run.</span><span class="x">
    </span><span class="n">Next</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">)</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>Golang 的接口和其它面向对象语言有所不同，接口和具体实现类不是一个强关联，如上面 Schedule 定义了一个方法 Next，那么任何一个实现了该方法的 struct 都相当于实现了这个接口，如代码中 SpecSchedule 这个 struct，我们可以说他实现了 Schedule 那个接口。如果是一个空接口，没有任何方法，那么所有的 struct 都实现了这个空接口。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// SpecSchedule specifies a duty cycle (to the second granularity), based on a</span><span class="x">
</span><span class="c">// traditional crontab specification. It is computed initially and stored as bit sets.</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">SpecSchedule</span><span class="x"> </span><span class="k">struct</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">Second</span><span class="p">,</span><span class="x"> </span><span class="n">Minute</span><span class="p">,</span><span class="x"> </span><span class="n">Hour</span><span class="p">,</span><span class="x"> </span><span class="n">Dom</span><span class="p">,</span><span class="x"> </span><span class="n">Month</span><span class="p">,</span><span class="x"> </span><span class="n">Dow</span><span class="x"> </span><span class="kt">uint64</span><span class="x">
    </span><span class="n">Location</span><span class="x">                              </span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">Location</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// Next returns the next time this schedule is activated, greater than the given</span><span class="x">
</span><span class="c">// time.  If no time can be found to satisfy the schedule, return the zero time.</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="o">*</span><span class="n">SpecSchedule</span><span class="p">)</span><span class="x"> </span><span class="n">Next</span><span class="p">(</span><span class="n">t</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">)</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// 此处代码省略</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>我们真正加入到 Entry 的 Schedule 都是 SpecSchedule，SpecSchedule 的 Next 方法主要是处理下一次 Job 运行时间的方法，该方法里还使用了 goto 关键字，在 Parse 阶段调用的 Parse() 方法将 crontab 格式的数据转换为 SpecSchedule 的实例。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WRAP</span><span class="o">:</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">Year</span><span class="p">()</span><span class="x"> </span><span class="o">&gt;</span><span class="x"> </span><span class="n">yearLimit</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="p">{}</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="c">// Find the first applicable month.</span><span class="x">
    </span><span class="c">// If it's this month, then do nothing.</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="m">1</span><span class="o">&lt;&lt;</span><span class="kt">uint</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">Month</span><span class="p">())</span><span class="o">&amp;</span><span class="n">s</span><span class="o">.</span><span class="n">Month</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="c">// If we have to add a month, reset the other parts to 0.</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="o">!</span><span class="n">added</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">added</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="no">true</span><span class="x">
            </span><span class="c">// Otherwise, set the date at the beginning (since the current time is irrelevant).</span><span class="x">
            </span><span class="n">t</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Date</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">Year</span><span class="p">(),</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">Month</span><span class="p">(),</span><span class="x"> </span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">,</span><span class="x"> </span><span class="n">s</span><span class="o">.</span><span class="n">Location</span><span class="p">)</span><span class="x">
        </span><span class="p">}</span><span class="x">
        </span><span class="n">t</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">AddDate</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="x"> </span><span class="m">1</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">)</span><span class="x">

        </span><span class="c">// Wrapped around.</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="n">t</span><span class="o">.</span><span class="n">Month</span><span class="p">()</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">January</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">goto</span><span class="x"> </span><span class="n">WRAP</span><span class="x">
        </span><span class="p">}</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>goto 关键字是 Golang 控制流程的关键字之一，用起来比较简单，就是在函数某个位置写个标签，后续流程里 goto 到这个标签，跟 C 语言里的 goto 类似。</p>

<p>接下来我们来说一说闭包，闭包这个概念大家多少都有些理解了，结合 cron.v2 的代码，我们来看一看</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// FuncJob is a wrapper that turns a func() into a cron.Job</span><span class="x">
</span><span class="k">type</span><span class="x"> </span><span class="n">FuncJob</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="c">// FuncJob 是一个函数类型，好比 type EntryId int</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">f</span><span class="x"> </span><span class="n">FuncJob</span><span class="p">)</span><span class="x"> </span><span class="n">Run</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x"> </span><span class="n">f</span><span class="p">()</span><span class="x"> </span><span class="p">}</span><span class="x"> </span><span class="c">// 给 FuncJob 增加了一个 Run 方法</span><span class="x">

</span><span class="c">// AddFunc adds a func to the Cron to be run on the given schedule.</span><span class="x">
</span><span class="c">// spec 就是 crontab 类似的时间格式 */1 * * * 1 或者 @every 5s 这类的</span><span class="x">
</span><span class="c">// cmd 这里传进来就是函数例如 AddFunc("@every 1s", func () { fmt.Println("Hello Func") })</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">c</span><span class="x"> </span><span class="o">*</span><span class="n">Cron</span><span class="p">)</span><span class="x"> </span><span class="n">AddFunc</span><span class="p">(</span><span class="n">spec</span><span class="x"> </span><span class="kt">string</span><span class="p">,</span><span class="x"> </span><span class="n">cmd</span><span class="x"> </span><span class="k">func</span><span class="p">())</span><span class="x"> </span><span class="p">(</span><span class="n">EntryID</span><span class="p">,</span><span class="x"> </span><span class="kt">error</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">AddJob</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span><span class="x"> </span><span class="n">FuncJob</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>看下这个例子</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">

</span><span class="k">type</span><span class="x"> </span><span class="n">FFF</span><span class="x"> </span><span class="k">func</span><span class="p">()</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">f</span><span class="x"> </span><span class="n">FFF</span><span class="p">)</span><span class="x"> </span><span class="n">printFFF</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">f</span><span class="p">()</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"printFFF"</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">fp</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">FFF</span><span class="p">(</span><span class="k">func</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"YoYoYo"</span><span class="p">)</span><span class="x">
    </span><span class="p">})</span><span class="x">
    </span><span class="n">fp</span><span class="o">.</span><span class="n">printFFF</span><span class="p">()</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello"</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span><span class="c">// 结果</span><span class="x">
</span><span class="c">// YoYoYo</span><span class="x">
</span><span class="c">// printFFF</span><span class="x">
</span><span class="c">// hello</span><span class="x">
</span></code></pre></div></div>

<p>接下来我们来看看 Run 部分的 <strong><em>go</em></strong> 关键字和 <strong><em>chan</em></strong>，这两个关键字可以说是 Golang 语言的精华所在了。<strong><em>go</em></strong> 关键字主要是用来创建一个 <strong><em>goroutine</em></strong>（协程），而 <strong><em>goroutine</em></strong> 和 <strong><em>chan</em></strong> 协作使用，来完成不同 <strong><em>goroutine</em></strong> 之间的通信。先看一个例子：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span><span class="x"> </span><span class="n">main</span><span class="x">

</span><span class="k">import</span><span class="x"> </span><span class="s">"fmt"</span><span class="x">
</span><span class="k">import</span><span class="x"> </span><span class="s">"time"</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">main</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="k">var</span><span class="x"> </span><span class="n">amChan</span><span class="x"> </span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="x">
    </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"来通个信"</span><span class="p">)</span><span class="x">
    </span><span class="n">amChan</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">chan</span><span class="x"> </span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="m">5</span><span class="p">)</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">5</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="c">// 注释1 go func() {</span><span class="x">
            </span><span class="n">amChan</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">i</span><span class="x">

        </span><span class="c">// 注释1 }()</span><span class="x">
        </span><span class="c">// 注释2 time.Sleep(100 * time.Millisecond)</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="m">0</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="x"> </span><span class="o">&lt;</span><span class="x"> </span><span class="m">5</span><span class="p">;</span><span class="x"> </span><span class="n">i</span><span class="o">++</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">result</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">amChan</span><span class="x">
        </span><span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>
<p>上面的代码，如果<code class="highlighter-rouge">注释 1 和 2</code>部分不打开，输出结果 <code class="highlighter-rouge">0 1 2 3 4</code>，如果只是打开<code class="highlighter-rouge">注释 1</code>，我们看到的结果会是 <code class="highlighter-rouge">5 5 5 5 5</code>，如果<code class="highlighter-rouge">注释 1 和 2</code>两部分都打开，则会输出 <code class="highlighter-rouge">0 1 2 3 4</code>。</p>

<p>chan 在我理解起来更像是一个队列，输入数据，取出数据，这里面 <code class="highlighter-rouge">注释 1 和 2</code> 带来不同的输出结果主要是因为 go 这个关键字开启协程导致的，协程是独立的处理单元，你无法知道他们什么时候真正的启动执行，而注释带来的就是代码逻辑顺序依赖变量 <code class="highlighter-rouge">i</code>，执行整个 for 循环以后，可能 go 的协程才执行，这样必然带来输出结果不一致的问题。下面我们看下 Cron.Run 方法调用的代码：</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Start the cron scheduler in its own go-routine.</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">c</span><span class="x"> </span><span class="o">*</span><span class="n">Cron</span><span class="p">)</span><span class="x"> </span><span class="n">Start</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="n">c</span><span class="o">.</span><span class="n">running</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="no">true</span><span class="x"> </span><span class="c">// 设置状态</span><span class="x">
    </span><span class="k">go</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">run</span><span class="p">()</span><span class="x"> </span><span class="c">// 通过协程来执行 run()</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// run the scheduler.. this is private just due to the need to synchronize</span><span class="x">
</span><span class="c">// access to the 'running' state variable.</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">c</span><span class="x"> </span><span class="o">*</span><span class="n">Cron</span><span class="p">)</span><span class="x"> </span><span class="n">run</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// Figure out the next activation times for each entry.</span><span class="x">
    </span><span class="n">now</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Local</span><span class="p">()</span><span class="x">
    </span><span class="c">// 设置下次执行时间</span><span class="x">
    </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">entry</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">entries</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="n">entry</span><span class="o">.</span><span class="n">Next</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">entry</span><span class="o">.</span><span class="n">Schedule</span><span class="o">.</span><span class="n">Next</span><span class="p">(</span><span class="n">now</span><span class="p">)</span><span class="x">
    </span><span class="p">}</span><span class="x">

    </span><span class="k">for</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="c">// Determine the next entry to run.</span><span class="x">
        </span><span class="c">// 排序当前任务的执行时间，排序方法见下面代码</span><span class="x">
        </span><span class="n">sort</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="n">byTime</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">entries</span><span class="p">))</span><span class="x">

        </span><span class="c">// effective 就是下次任务要执行的时间</span><span class="x">
        </span><span class="k">var</span><span class="x"> </span><span class="n">effective</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Time</span><span class="x">
        </span><span class="k">if</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">entries</span><span class="p">)</span><span class="x"> </span><span class="o">==</span><span class="x"> </span><span class="m">0</span><span class="x"> </span><span class="o">||</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">Next</span><span class="o">.</span><span class="n">IsZero</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="c">// 此处是任务为空时处理逻辑</span><span class="x">
            </span><span class="c">// If there are no entries yet, just sleep - it still handles new entries</span><span class="x">
            </span><span class="c">// and stop requests.</span><span class="x">
            </span><span class="n">effective</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">now</span><span class="o">.</span><span class="n">AddDate</span><span class="p">(</span><span class="m">10</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">,</span><span class="x"> </span><span class="m">0</span><span class="p">)</span><span class="x">
        </span><span class="p">}</span><span class="x"> </span><span class="k">else</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="n">effective</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">entries</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="o">.</span><span class="n">Next</span><span class="x">
        </span><span class="p">}</span><span class="x">
        </span><span class="c">// Golang 针对 chan 的读写操作，提供了 select 语句，</span><span class="x">
        </span><span class="c">// 可以用 select 来检测或者阻塞 chan 操作的，</span><span class="x">
        </span><span class="c">// select 会评估 case 语句块，只要有任何一个评估通过，</span><span class="x">
        </span><span class="c">// 就会执行对应的语句，如果都无法通过评估，</span><span class="x">
        </span><span class="c">// 则会一直阻塞，直到有语句可以评估通过。</span><span class="x">
        </span><span class="c">// 如果都无法通过评估且语句有 `default` 块，则执行 `default` 部分</span><span class="x">
        </span><span class="k">select</span><span class="x"> </span><span class="p">{</span><span class="x">
            </span><span class="k">case</span><span class="x"> </span><span class="n">now</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">time</span><span class="o">.</span><span class="n">After</span><span class="p">(</span><span class="n">effective</span><span class="o">.</span><span class="n">Sub</span><span class="p">(</span><span class="n">now</span><span class="p">))</span><span class="o">:</span><span class="x">
                </span><span class="c">// Run every entry whose next time was this effective time.</span><span class="x">
                </span><span class="k">for</span><span class="x"> </span><span class="n">_</span><span class="p">,</span><span class="x"> </span><span class="n">e</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">entries</span><span class="x"> </span><span class="p">{</span><span class="x">
                    </span><span class="k">if</span><span class="x"> </span><span class="n">e</span><span class="o">.</span><span class="n">Next</span><span class="x"> </span><span class="o">!=</span><span class="x"> </span><span class="n">effective</span><span class="x"> </span><span class="p">{</span><span class="x">
                        </span><span class="k">break</span><span class="x">
                    </span><span class="p">}</span><span class="x">
                    </span><span class="k">go</span><span class="x"> </span><span class="n">e</span><span class="o">.</span><span class="n">Job</span><span class="o">.</span><span class="n">Run</span><span class="p">()</span><span class="x">
                    </span><span class="n">e</span><span class="o">.</span><span class="n">Prev</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">e</span><span class="o">.</span><span class="n">Next</span><span class="x">
                    </span><span class="n">e</span><span class="o">.</span><span class="n">Next</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">e</span><span class="o">.</span><span class="n">Schedule</span><span class="o">.</span><span class="n">Next</span><span class="p">(</span><span class="n">effective</span><span class="p">)</span><span class="x">
                </span><span class="p">}</span><span class="x">
                </span><span class="k">continue</span><span class="x">

            </span><span class="k">case</span><span class="x"> </span><span class="n">newEntry</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">c</span><span class="o">.</span><span class="n">add</span><span class="o">:</span><span class="x">
                </span><span class="n">c</span><span class="o">.</span><span class="n">entries</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">entries</span><span class="p">,</span><span class="x"> </span><span class="n">newEntry</span><span class="p">)</span><span class="x">
                </span><span class="n">newEntry</span><span class="o">.</span><span class="n">Next</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">newEntry</span><span class="o">.</span><span class="n">Schedule</span><span class="o">.</span><span class="n">Next</span><span class="p">(</span><span class="n">now</span><span class="p">)</span><span class="x">

            </span><span class="k">case</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">c</span><span class="o">.</span><span class="n">snapshot</span><span class="o">:</span><span class="x">
                </span><span class="n">c</span><span class="o">.</span><span class="n">snapshot</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">c</span><span class="o">.</span><span class="n">entrySnapshot</span><span class="p">()</span><span class="x">

            </span><span class="k">case</span><span class="x"> </span><span class="n">id</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">c</span><span class="o">.</span><span class="n">remove</span><span class="o">:</span><span class="x">
                </span><span class="n">c</span><span class="o">.</span><span class="n">removeEntry</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="x">

            </span><span class="k">case</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">c</span><span class="o">.</span><span class="n">stop</span><span class="o">:</span><span class="x">
                </span><span class="k">return</span><span class="x">
        </span><span class="p">}</span><span class="x">

        </span><span class="n">now</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">Local</span><span class="p">()</span><span class="x">
    </span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>整个 Cron 运行的时候，就是个无限循环，不停的循环 <code class="highlighter-rouge">Cron.entries</code>，每次循环一个 Entry 任务出来，并计算该任务下次的执行时间，在循环 <code class="highlighter-rouge">entries</code> 前对其排序，将最近要执行的任务取出来进行和当前时间对比，反复如此，下面就是排序相关代码 <code class="highlighter-rouge">sort.Sort(byTime(c.entries))</code></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span><span class="x"> </span><span class="n">byTime</span><span class="x"> </span><span class="p">[]</span><span class="o">*</span><span class="n">Entry</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="n">byTime</span><span class="p">)</span><span class="x"> </span><span class="n">Len</span><span class="p">()</span><span class="x"> </span><span class="kt">int</span><span class="x">      </span><span class="p">{</span><span class="x"> </span><span class="k">return</span><span class="x"> </span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="x"> </span><span class="p">}</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="n">byTime</span><span class="p">)</span><span class="x"> </span><span class="n">Swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="x"> </span><span class="p">}</span><span class="x">
</span><span class="k">func</span><span class="x"> </span><span class="p">(</span><span class="n">s</span><span class="x"> </span><span class="n">byTime</span><span class="p">)</span><span class="x"> </span><span class="n">Less</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="x"> </span><span class="n">j</span><span class="x"> </span><span class="kt">int</span><span class="p">)</span><span class="x"> </span><span class="kt">bool</span><span class="x"> </span><span class="p">{</span><span class="x">
    </span><span class="c">// Two zero times should return false.</span><span class="x">
    </span><span class="c">// Otherwise, zero is "greater" than any other time.</span><span class="x">
    </span><span class="c">// (To sort it at the end of the list.)</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Next</span><span class="o">.</span><span class="n">IsZero</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="no">false</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">if</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">Next</span><span class="o">.</span><span class="n">IsZero</span><span class="p">()</span><span class="x"> </span><span class="p">{</span><span class="x">
        </span><span class="k">return</span><span class="x"> </span><span class="no">true</span><span class="x">
    </span><span class="p">}</span><span class="x">
    </span><span class="k">return</span><span class="x"> </span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">Next</span><span class="o">.</span><span class="n">Before</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">Next</span><span class="p">)</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>EOF;</p>

  </div>

  

  <a class="u-url" href="/cron.v2/golang/chan/timer/2018/03/23/go-cron-v2.html" hidden></a>
</article>

      </div>
    </main>

    <footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Rust.Love</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            
              Rust.Love
            
            </li>
            
            <li><a class="u-email" href="mailto:pochonleeATgmail.com">pochonleeATgmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
  
  
  
  <li><a href="https://github.com/outman"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">outman</span></a></li>
  
  
  
  <li><a href="https://www.twitter.com/pochonlee"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">pochonlee</span></a></li>
  
  
  
</ul>

      </div>

      <div class="footer-col footer-col-3">
        <p>Freedom &amp; Responsibility.</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
