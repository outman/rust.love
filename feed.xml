<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://rust.love/feed.xml" rel="self" type="application/atom+xml" /><link href="http://rust.love/" rel="alternate" type="text/html" /><updated>2019-05-01T13:24:16+08:00</updated><id>http://rust.love/</id><title type="html">Rust.Love</title><subtitle>Freedom &amp; Responsibility.</subtitle><entry><title type="html">Tomcat 无法启动并且没有错误，一直 loading</title><link href="http://rust.love/tomcat/java/2019/05/01/tomcat-can-not-startup.html" rel="alternate" type="text/html" title="Tomcat 无法启动并且没有错误，一直 loading" /><published>2019-05-01T00:00:00+08:00</published><updated>2019-05-01T00:00:00+08:00</updated><id>http://rust.love/tomcat/java/2019/05/01/tomcat-can-not-startup</id><content type="html" xml:base="http://rust.love/tomcat/java/2019/05/01/tomcat-can-not-startup.html">&lt;p&gt;Tomcat deploy war 包的时候一直处于 loading 状态，没有任何错误日志，一直处于 init
中，而且程序也没有日志输入。通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dtruss&lt;/code&gt; (linux 上可以使用 pstrace)
追踪发现因为 Tomcat 一直找不到一个目录，所以不停的在重试&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;psynch_cvwait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x7F8A93E09568&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x40A0100040B00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x40A00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;psynch_cvwait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x7F8A93C36368&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2490100024A00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x24900&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;gettimeofday&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x7000041DAB00&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stat64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/usr/local/apache-tomcat-7.0.56/webapps/parkManage/WEB-INF/classes/some/package/xml/mapping\0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x700004BCEFF0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stat64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/usr/local/apache-tomcat-7.0.56/lib/some/package/xml/mapping\0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x700004BCE7B0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stat64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/usr/local/apache-tomcat-7.0.56/webapps/parkManage/WEB-INF/classes/some/package/xml/mapping\0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x700004BCE760&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stat64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/usr/local/apache-tomcat-7.0.56/lib/some/package/xml/mapping\0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x700004BCDF20&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stat64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/usr/local/apache-tomcat-7.0.56/webapps/parkManage/WEB-INF/classes/some/package/xml/mapping\0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x700004BCEFF0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stat64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/usr/local/apache-tomcat-7.0.56/lib/some/package/xml/mapping\0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x700004BCE7B0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;stat64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/usr/local/apache-tomcat-7.0.56/webapps/parkManage/WEB-INF/classes/some/package/xml/mapping\0&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x700004BCF880&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过项目查看该目录不存在，mvn 打包时没有打包该目录，检查 pom.xml
文件发现是目录写错了，所以打包时被忽略了。&lt;/p&gt;

&lt;p&gt;解决方式是修改 pom.xml 重新打包。&lt;/p&gt;

&lt;p&gt;PS: 注意 &lt;code class=&quot;highlighter-rouge&quot;&gt;dtruss&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;pstrace&lt;/code&gt;
这些工具，可以在关键时刻帮你快速定位问题，因为是后期维护的项目，所以特别困惑当时第一次的项目是怎么部署的。&lt;/p&gt;

&lt;p&gt;EOF;&lt;/p&gt;</content><author><name></name></author><summary type="html">Tomcat deploy war 包的时候一直处于 loading 状态，没有任何错误日志，一直处于 init 中，而且程序也没有日志输入。通过 dtruss (linux 上可以使用 pstrace) 追踪发现因为 Tomcat 一直找不到一个目录，所以不停的在重试</summary></entry><entry><title type="html">PHP empty doesn’t work with a getter method</title><link href="http://rust.love/php/empty/getter/2019/01/16/php-empty-doesnot-work-with-a-getter-method.html" rel="alternate" type="text/html" title="PHP empty doesn't work with a getter method" /><published>2019-01-16T00:00:00+08:00</published><updated>2019-01-16T00:00:00+08:00</updated><id>http://rust.love/php/empty/getter/2019/01/16/php-empty-doesnot-work-with-a-getter-method</id><content type="html" xml:base="http://rust.love/php/empty/getter/2019/01/16/php-empty-doesnot-work-with-a-getter-method.html">```php
 25    private function getPostTagNested()
 24    {
 23        if (!is_array($this-&gt;nearByParams-&gt;tag_id)
 22            || empty($this-&gt;nearByParams-&gt;tag_id)) {
 21            return null;
 20        }
 19
 18        $nestedQuery = new Nested();
 17        $nestedQuery-&gt;setPath('jz_post_2_tag');
 16
 15        $boolQuery = new BoolQuery();
 14        $boolQuery-&gt;addMust(new Terms('jz_post_2_tag.tag_id', $this-&gt;nearByParams-&gt;tag_id));
 13        $boolQuery-&gt;addMust(new Term([
 12            'jz_post_2_tag.listing_status' =&gt; 5,
 11        ]));
 10
  9        $nestedQuery-&gt;setQuery($boolQuery);
  8
  7        return $nestedQuery;
  6    }
```

tag_id 在有值的情况下，这个代码的地 22 行出现了一个 bug，发现 nearByParams-&gt;tag_id 的 tag_id 是 private 的，之后又发现在 nearByParams 这个对象里，实现了 __get 方法，empty 在执行的时候，先触发了 nearByParams 这个对象的 __isset 方法，之后才会调用 __get 方法。如果没有实现 __isset 方法，这个 empty 函数的调用就会出现错误的判断。</content><author><name></name></author><summary type="html">25 private function getPostTagNested() 24 { 23 if (!is_array($this-&amp;gt;nearByParams-&amp;gt;tag_id) 22 || empty($this-&amp;gt;nearByParams-&amp;gt;tag_id)) { 21 return null; 20 } 19 18 $nestedQuery = new Nested(); 17 $nestedQuery-&amp;gt;setPath('jz_post_2_tag'); 16 15 $boolQuery = new BoolQuery(); 14 $boolQuery-&amp;gt;addMust(new Terms('jz_post_2_tag.tag_id', $this-&amp;gt;nearByParams-&amp;gt;tag_id)); 13 $boolQuery-&amp;gt;addMust(new Term([ 12 'jz_post_2_tag.listing_status' =&amp;gt; 5, 11 ])); 10 9 $nestedQuery-&amp;gt;setQuery($boolQuery); 8 7 return $nestedQuery; 6 }</summary></entry><entry><title type="html">MySQL init buffer pool MMP</title><link href="http://rust.love/mysql/bufferpool/mmp/2019/01/03/mysql-init-buffer-pool-mmap.html" rel="alternate" type="text/html" title="MySQL init buffer pool MMP" /><published>2019-01-03T00:00:00+08:00</published><updated>2019-01-03T00:00:00+08:00</updated><id>http://rust.love/mysql/bufferpool/mmp/2019/01/03/mysql-init-buffer-pool-mmap</id><content type="html" xml:base="http://rust.love/mysql/bufferpool/mmp/2019/01/03/mysql-init-buffer-pool-mmap.html">```sql
2018-12-01T09:43:57.192137Z 0 [Note] /data/services/local/mysql/bin/mysqld (mysqld 5.7.22) starting as process 914 ...
2018-12-01T09:43:57.331587Z 0 [Note] InnoDB: PUNCH HOLE support available
2018-12-01T09:43:57.331634Z 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins
2018-12-01T09:43:57.331639Z 0 [Note] InnoDB: Uses event mutexes
2018-12-01T09:43:57.331643Z 0 [Note] InnoDB: GCC builtin __sync_synchronize() is used for memory barrier
2018-12-01T09:43:57.331646Z 0 [Note] InnoDB: Compressed tables use zlib 1.2.3
2018-12-01T09:43:57.331650Z 0 [Note] InnoDB: Using Linux native AIO
2018-12-01T09:43:57.331929Z 0 [Note] InnoDB: Number of pools: 1
2018-12-01T09:43:57.332035Z 0 [Note] InnoDB: Using CPU crc32 instructions
2018-12-01T09:43:57.333976Z 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M
2018-12-01T09:43:57.334005Z 0 [ERROR] InnoDB: mmap(137428992 bytes) failed; errno 12
2018-12-01T09:43:57.334013Z 0 [ERROR] InnoDB: Cannot allocate memory for the buffer pool
2018-12-01T09:43:57.334017Z 0 [ERROR] InnoDB: Plugin initialization aborted with error Generic error
2018-12-01T09:43:57.334023Z 0 [ERROR] Plugin 'InnoDB' init function returned error.
2018-12-01T09:43:57.334027Z 0 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.
2018-12-01T09:43:57.334032Z 0 [ERROR] Failed to initialize builtin plugins.
```

setting my.cnf

```mysql
innodb_buffer_pool_size=50M
```</content><author><name></name></author><summary type="html">2018-12-01T09:43:57.192137Z 0 [Note] /data/services/local/mysql/bin/mysqld (mysqld 5.7.22) starting as process 914 ... 2018-12-01T09:43:57.331587Z 0 [Note] InnoDB: PUNCH HOLE support available 2018-12-01T09:43:57.331634Z 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins 2018-12-01T09:43:57.331639Z 0 [Note] InnoDB: Uses event mutexes 2018-12-01T09:43:57.331643Z 0 [Note] InnoDB: GCC builtin __sync_synchronize() is used for memory barrier 2018-12-01T09:43:57.331646Z 0 [Note] InnoDB: Compressed tables use zlib 1.2.3 2018-12-01T09:43:57.331650Z 0 [Note] InnoDB: Using Linux native AIO 2018-12-01T09:43:57.331929Z 0 [Note] InnoDB: Number of pools: 1 2018-12-01T09:43:57.332035Z 0 [Note] InnoDB: Using CPU crc32 instructions 2018-12-01T09:43:57.333976Z 0 [Note] InnoDB: Initializing buffer pool, total size = 128M, instances = 1, chunk size = 128M 2018-12-01T09:43:57.334005Z 0 [ERROR] InnoDB: mmap(137428992 bytes) failed; errno 12 2018-12-01T09:43:57.334013Z 0 [ERROR] InnoDB: Cannot allocate memory for the buffer pool 2018-12-01T09:43:57.334017Z 0 [ERROR] InnoDB: Plugin initialization aborted with error Generic error 2018-12-01T09:43:57.334023Z 0 [ERROR] Plugin 'InnoDB' init function returned error. 2018-12-01T09:43:57.334027Z 0 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed. 2018-12-01T09:43:57.334032Z 0 [ERROR] Failed to initialize builtin plugins.</summary></entry><entry><title type="html">dom4j DocumentHelper XXE 注入</title><link href="http://rust.love/dom4j/documenthelper/xxe/java/2018/12/29/dom4j-doucument-helper-xxe-inject.html" rel="alternate" type="text/html" title="dom4j DocumentHelper XXE 注入" /><published>2018-12-29T00:00:00+08:00</published><updated>2018-12-29T00:00:00+08:00</updated><id>http://rust.love/dom4j/documenthelper/xxe/java/2018/12/29/dom4j-doucument-helper-xxe-inject</id><content type="html" xml:base="http://rust.love/dom4j/documenthelper/xxe/java/2018/12/29/dom4j-doucument-helper-xxe-inject.html">因为之前微信支付的 XXE
注入安全问题，周末帮别人修这个问题，做了一下笔记。因为使用的是
dom4j，所以为了兼容之前的库，做了简单修改。

代码中 Section 1 是原始代码，Section 2 是修复后的代码，injectXML 是用于测试的代码，测试代码注入的部分是读取 /etc/hosts 文件，注意 methodname 节点，&amp;xxe 引用，在测试 Section 2 的时候，去除引用。

 ```java

import java.io.StringReader;
import java.util.List;
import java.util.SortedMap;
import java.util.StringTokenizer;
import java.util.TreeMap;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.io.SAXReader;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

public class XXEInject {

	public static void main(String[] args) throws DocumentException {

		String injectXML = &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;utf-8\&quot;?&gt;\n&quot; +
				&quot;&lt;!DOCTYPE xdsec [\n&quot; +
				&quot;    &lt;!ELEMENT methodname ANY&gt;\n&quot; +
				&quot;    &lt;!ENTITY xxe SYSTEM \&quot;file:///etc/hosts\&quot;&gt;\n&quot; +
				&quot;]&gt;\n&quot; +
				&quot;&lt;methodcall&gt;\n&quot; +
				&quot;&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;\n&quot; +
				&quot;&lt;/methodcall&gt;&quot;;

		/**
		 * unsafe
		 * Section 1
		 */
//		Document document = DocumentHelper.parseText(injectXML);
		/**
		 * Section 1 end
		 */

		/**
		 * safe
		 * Section 2
		 */
		// 修复 XXE 注入
		SAXReader reader = new SAXReader();

		try {
			reader.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
		} catch (SAXException e1) {
			throw new DocumentException(e1.getMessage());
		}

		String encoding = getEncoding(injectXML);

		InputSource source = new InputSource(new StringReader(injectXML));
		source.setEncoding(encoding);

		Document document = reader.read(source);
		/**
		 * Section 2 end
		 */

		Element root = document.getRootElement();
		List&lt;Element&gt; list = root.elements();

		SortedMap&lt;String, String&gt; map = null;
		if(list!=null &amp;&amp; list.size()&gt;0){
			map = new TreeMap&lt;String, String&gt;();
			for(Element e : list){
				String k = e.getName();
				String v = e.getText();
				System.out.println(k+&quot; : &quot;+v);
				map.put(k, v);
			}
		}
	}

	/**
	 * 处理 XXE 注入，方法来自 dom4j
	 * @param text
	 * @return String
	 */
	private static String getEncoding(String text) {
		String result = null;
		String xml = text.trim();
		if (xml.startsWith(&quot;&lt;?xml&quot;)) {
			int end = xml.indexOf(&quot;?&gt;&quot;);
			String sub = xml.substring(0, end);
			StringTokenizer tokens = new StringTokenizer(sub, &quot; =\&quot;'&quot;);
			while (tokens.hasMoreTokens()) {
				String token = tokens.nextToken();
				if (&quot;encoding&quot;.equals(token)) {
					if (!tokens.hasMoreTokens()) {
						break;
					}
					result = tokens.nextToken();
					break;
				}
			}
		}
		return result;

	}

}

```</content><author><name></name></author><summary type="html">因为之前微信支付的 XXE 注入安全问题，周末帮别人修这个问题，做了一下笔记。因为使用的是 dom4j，所以为了兼容之前的库，做了简单修改。</summary></entry><entry><title type="html">PHP curl timeout trace</title><link href="http://rust.love/php/curl/timeout/trace/2018/11/08/curl-timeout-trace.html" rel="alternate" type="text/html" title="PHP curl timeout trace" /><published>2018-11-08T00:00:00+08:00</published><updated>2018-11-08T00:00:00+08:00</updated><id>http://rust.love/php/curl/timeout/trace/2018/11/08/curl-timeout-trace</id><content type="html" xml:base="http://rust.love/php/curl/timeout/trace/2018/11/08/curl-timeout-trace.html">平时大家很多地方使用了 php 的 `curl` 模块，在排查超时问题上有时候方法不当，不能正确的定位超时在哪个阶段，在这里主要是把 `curl` 模块文档里的一个函数给大家说一下，`curl_getinfo` 这个函数，先说下发起 curl 请求后的几个关键时间点阶段如下图，

![curl请求](/assets/images/curl_timeline.png)

根据上面的这个图，大家应该就能明白排查超时定位问题的方向了，这个图里的各个阶段的时间点就可以通过 [curl_getinfo](http://php.net/manual/en/function.curl-getinfo.php) 来获得了。

1、直接用 curl_* 自己构造的请求，直接通过 curl_getinfo 就可以获得。

2、通过第三方库 GuzzleHttp 来获得这个时间代码示例

```php
    // $this-&gt;initClient = new \GuzzleHttp\Client();
    $response = $this-&gt;initClient()-&gt;post($this-&gt;serverUrl, [
        'form_params' =&gt; $formParams,
        'headers' =&gt; $headers,
        'timeout' =&gt; $this-&gt;timeout,
        'connect_timeout' =&gt; $this-&gt;connectionTimeout,
        'http_errors' =&gt; true,
        'debug' =&gt; $this-&gt;debug,
        // TransferStats 注意这个
        'on_stats' =&gt; $this-&gt;debug ?  function (TransferStats $stats) {
            print_r($stats-&gt;getHandlerStats());
        } : null,
    ]);
```

具体每个时间段的参数代表的具体含义，大家自行参考文档。

EOT;</content><author><name></name></author><summary type="html">平时大家很多地方使用了 php 的 curl 模块，在排查超时问题上有时候方法不当，不能正确的定位超时在哪个阶段，在这里主要是把 curl 模块文档里的一个函数给大家说一下，curl_getinfo 这个函数，先说下发起 curl 请求后的几个关键时间点阶段如下图，</summary></entry><entry><title type="html">Linux install MySQL step by step</title><link href="http://rust.love/linux/mysql/2018/09/13/install-mysql-step-by-step.html" rel="alternate" type="text/html" title="Linux install MySQL step by step" /><published>2018-09-13T00:00:00+08:00</published><updated>2018-09-13T00:00:00+08:00</updated><id>http://rust.love/linux/mysql/2018/09/13/install-mysql-step-by-step</id><content type="html" xml:base="http://rust.love/linux/mysql/2018/09/13/install-mysql-step-by-step.html">Install MySQL step by step

#### download mysql-{version}-linux-glibc2.12-{arch}.tar.gz
```shell
cp mysql-{version}-linux-glibc2.12-{arch}.tar.gz /your-mysql-prefix-path/
tar zxvf mysql-{version}-linux-glibc2.12-{arch}.tar.gz
mv mysql-{version}-linux-glibc2.12-{arch} mysql
vi /etc/my.cnf
cd mysql

# --lc-messages-dir=/your-mysql-prefix-path/mysql/share
./bin/mysqld --initialize

cp support-files/mysql.server /etc/init.d/mysql
service mysql start
./bin/mysql -uroot -h127.0.0.1 -p
```</content><author><name></name></author><summary type="html">Install MySQL step by step</summary></entry><entry><title type="html">Elasticsearch 查询 Size 过大</title><link href="http://rust.love/elasticsearch/query/size/legacy/2018/05/18/crash-your-elasticsearch.html" rel="alternate" type="text/html" title="Elasticsearch 查询 Size 过大" /><published>2018-05-18T00:00:00+08:00</published><updated>2018-05-18T00:00:00+08:00</updated><id>http://rust.love/elasticsearch/query/size/legacy/2018/05/18/crash-your-elasticsearch</id><content type="html" xml:base="http://rust.love/elasticsearch/query/size/legacy/2018/05/18/crash-your-elasticsearch.html">今天检索那边爆了一个慢查询，通过查询语句发现是检索那边某服务的一个查询，
语句类似：

```php
{
    query: {
        user_id : 'xxxx'
    },
    size: 2147483647
}
```

这个查询条件比较简单，而且也是精确查询，但是花了 2秒多，问题出在 size 上，
这个巨大的 size 是 java 里的 Integer.MAX_VALUE，Elasticsearch 在查询时，
会为查询结果准备数据结构和存储空间，由于这个结果 size 巨大，所以在准备阶段话费了
巨大时间，但最后的真实结果只有几条记录。

具体可以看下面的这个链接的 Arbitrary Large Size Parameter 部分：

&gt; if the size parameter is ridiculously large, then the Elasticsearch will create a ridiculously large internal data structure. And the one who pays the price is you, waiting forever - or so it seems! - for an insignificant result.

参考链接：
[https://www.elastic.co/blog/found-crash-elasticsearch#too-many-shards-or-the-gazillion-shards-problem](https://www.elastic.co/blog/found-crash-elasticsearch#too-many-shards-or-the-gazillion-shards-problem)</content><author><name></name></author><summary type="html">今天检索那边爆了一个慢查询，通过查询语句发现是检索那边某服务的一个查询， 语句类似：</summary></entry><entry><title type="html">gPRC 实践应用（1）（一周学习报-第7期）</title><link href="http://rust.love/grpc/grpc-go/go/linkerd/consul/2018/04/27/grpc-go.html" rel="alternate" type="text/html" title="gPRC 实践应用（1）（一周学习报-第7期）" /><published>2018-04-27T00:00:00+08:00</published><updated>2018-04-27T00:00:00+08:00</updated><id>http://rust.love/grpc/grpc-go/go/linkerd/consul/2018/04/27/grpc-go</id><content type="html" xml:base="http://rust.love/grpc/grpc-go/go/linkerd/consul/2018/04/27/grpc-go.html">&gt; 为什么是实践应用（1）？因为每一个软件都有很多事儿，稍后我们会拆分章节分到每一期去整理和讲解。


目前我们有一部分内部服务是通过 gRPC 构建的，这里主要讲下 gRPC 在我们这的一点实践，主要分下面几个主题，帮助大家了解我们的是如何在使用和部署 gRPC 服务的，帮助大家理一下思路。下面这个图，是当前我们 gRPC 服务相关的架构图，之后会针对每一块给大家做个介绍。本期意在讲述我们的架构部署和对应的服务有哪些服务构建，具体细节分期以后再讲。

![gRPC 服务架构图](/assets/images/grpc.jpeg)

### gRPC

RPC（Remote Procedure Call）一种远程调用协议，本身是一种语言无关的协议，简单说就是本地调用远程方法，而这种调用非常简单，对于本地试用者就像调用本地方法一样。关于 RPC 的服务框架有很多，这些框架使得使用 RPC 服务的人，更加专注业务，而不用更多的去关注通信、协议等实现，例如你调用了一个远程方法获取用户信息，在框架范围内只需要在本地执行 **this-&gt;callRemoteUserInfoByUserId(123456)** 就完成了用户信息的获取。 gRPC 也是一种 RPC 服务框架，类似的还有 Facebook 的 thrift，我们的服务扣费等功能，就是 thrift 实现的，还有频次控制服务也是 thrift 的。关于 gRPC 的文档说明和定义，都有了[中文翻译版本](https://skyao.io/learning-grpc/grpc/motivation.html)这里不在复述。

### protobuf

因为 RPC 服务是语言无关的，所以在不同语言上，就需要一个介质进行不同语言之间的数据转换，一般可以理解为不同语言间的序列化和反序列化，现在最常用的可能是 json 格式，例如 php 服务端接口生成的 json 为客户端 android 或者 iOS 提供服务。又如 RPC 服务 java 做服务端，php 做客户端，那么 php 和 java 之间就需要进行数据格式转换，Protocol Buffers 就是 Google 开源的一套数据转换格式（或者称之为协议），而且 Google 也提供了全套的工具，可以根据 protocol buffers 的数据 **.proto** 文件，生成对应的客户端和服务端代码，让不同编程语言之间通过该格式进行数据转换，而这种转换完全又工具生成，我们只关注服务及方法调用和自己的业务，让开发人员从代码、网络交互等工作中解脱出来。

既然是一种协议或者是数据结构，那就又定义这种结构的语法，这里有一个关于 **.proto**  语法的翻译的[中文文档](http://colobu.com/2015/01/07/Protobuf-language-guide/)，（顺便说下这个博客的作者是位技术大牛，上面有很多非常不错的技术文章。），稍后的例子中，我们也会提供一个 **.proto** 的文件。

### Linkerd

Linkerd 是一款开源网络代理，旨在作为服务网格进行部署，用于在应用程序内管理、控制和监视服务到服务通信的专用层，也是一套服务治理框架，他提供了性能看板等服务，通过性能看板我们可以直观的看到当前服务的状态。还有很多更强大的功能，包括负载均衡、服务发现等，也提供了多种部署方式，（之前技术部的微服务分享中有讲过，这里不在复述）。和其类似比较火的还有[Istio](https://istio.io/)

### Consul

Consul 主要是提供服务发现、健康检查等服务的服务，何其相似的软件又大名鼎鼎的 [zookeeper](https://zookeeper.apache.org/)、 [etcd](https://github.com/coreos/etcd) 等。关于服务发现等软件解决的问题不用说太多，大家也都应该了解了。

### 示例

目前我们已经在使用一些 RPC 服务了，就像前面说的线上已经部署了一些 thrift 的服务，还有之前我们推荐服务的也是 gRPC 服务，之前我们一直是作为客户端使用 gRPC 服务，这次的例子主要是客户端和服务端都涉及。当前线上的服务可以通过 host:9990 来查看 dashboard。

下面我们围绕一个 ApplyService 服务来讲解，看看完成一个服务需要我们做哪些事情。

![完成一个服务需要我们做哪些事情？](/assets/images/service_flow.jpeg)

#### 基础环境安装

客户端
- php 的 grpc 扩展
- php 的 composer 扩展包 grpc/grpc google/protobuf

服务端
- go
- grpc-go

proto 工具
- protoc 代码生成工具和对应的语言插件 grpc_php_plugin protoc-gen-go 等

#### 定义 proto 文件

$ cat services/apply/apply.proto
```proto
syntax = &quot;proto3&quot;;

// package 名称，因为不同的语言在 package 管理上方式不同，
// 所以 proto 提供了 option 关键字，来帮助不同语言之间让 package 更加友好
// 因为我们是把这部分服务单独放在项目里的，通过客户端通过 composer 统一管理，
// 所以用了单独的目录和独立的名称空间 pluto，php 生成的代码名称空间就是
// namespace Pluto\Services\Apply;
// 在 composer.json 内加入 autoload 模块
// &quot;autoload&quot; : {
//    &quot;psr-4&quot;: {
//        &quot;Pluto\\&quot;: &quot;grpc/Pluto/&quot;,
//    }
// }
package pluto.services.apply;

// 为了上面所说的生成 golang 友好的 package 而设定的
option go_package = &quot;apply&quot;;

service ApplyService {

    // 一个 rpc 调用
    rpc FetchApplyByUid(ApplyRequest) returns (ApplyResponse) {};
}

// 请求
message ApplyRequest {
    string uid = 1;
}

// 响应
message ApplyResponse {
   string result = 1;
}
```

&gt; 除了正常的业务定义以外，我们跟多方合作时，为了语言上的友好，尽量通过 option 关键字，来定义语言友好的包名，让代码组织起来不混乱。

#### 客户端代码生成

```
protoc --php_out=grpc/ --grpc_out=grpc/ --plugin=protoc-gen-grpc=/usr/local/bin/grpc_php_plugin resource/apply.proto
```

protoc-gen-grpc 这个插件完成了 Client 类的生成，如果不安装该插件也可以生成代码，但是 Client 里面的逻辑要自己去加入。除了生成的基础类以外，我们看下 Client 这个文件
```php
&lt;?php
// GENERATED CODE -- DO NOT EDIT!

namespace Pluto\Services\Apply;

/**
 */
class ApplyServiceClient extends \Grpc\BaseStub {

    /**
     * @param string $hostname hostname
     * @param array $opts channel options
     * @param \Grpc\Channel $channel (optional) re-use channel object
     */
    public function __construct($hostname, $opts, $channel = null) {
        parent::__construct($hostname, $opts, $channel);
    }

    /**
     * @param \Pluto\Services\Apply\ApplyRequest $argument input argument
     * @param array $metadata metadata
     * @param array $options call options
     */
    public function FetchApplyByUid(\Pluto\Services\Apply\ApplyRequest $argument,
      $metadata = [], $options = []) {

        // 注意这一段代码
        // pluto.services.apply.ApplyService 这个就是服务名称，
        // 我们后续会使用到这个名字
        return $this-&gt;_simpleRequest('/pluto.services.apply.ApplyService/FetchApplyByUid',
        $argument,
        ['\Pluto\Services\Apply\ApplyResponse', 'decode'],
        $metadata, $options);
    }

}
```

PHP 客户端调用代码
```php
// 这里需要注意 php 的 grpc 扩展的版本，及时升级最新版，
// 笔者开始时测试 10w 次请求发现客户端内存飙升，查了 github issue 发现是因为有内存泄漏
// 官方在新版本修复了
private function callGrpc($id, $output)
{
    // 请求对象初始化
    $request = new ApplyRequest();
    $request-&gt;setUid($id);

    // 初始化 Client
    // 此处配置的是 linkerd 的 4141 代理端口，我们服务用的是 9527 端口
    // 稍后会说明
    $client = new ApplyServiceClient(&quot;127.0.0.1:4141&quot;, [
        'credentials' =&gt;ChannelCredentials::createInsecure(),
        'timeout' =&gt; 1000000,
    ]);

    // 调用服务
    list($reply, $status) = $client-&gt;FetchApplyByUid($request)-&gt;wait();
    var_dump($reply-&gt;getResult());
    $output-&gt;writeln($reply-&gt;getResult());
}
```
#### 服务单 golang 代码生成

根据自己组织的目录进行代码生成，根据我们的定义，会生成一个 apply.pb.go 文件
```
protoc --go_out=plugins=grpc:. *.proto
```

先整体看下我们 golang 服务端的代码结构
```go
.
├── Makefile
├── README.md
├── bin // 编译后的二进制文件目录
│   └── pluto
├── config // 配置文件
│   └── config.yaml
├── glide.lock
├── glide.yaml
├── logs
├── main.go // 主程序
├── services
│   ├── apply
│   └── apply.go // ApplyService 的业务代码
├── util // 工具等目录
│   ├── init.go
│   └── storage.go
└── vendor // 依赖
    ├── github.com
    ├── golang.org
    ├── google.golang.org
    └── gopkg.in
```

$ cat services/apply/apply.pb.go 注意这部分代码 ServiceName 的注释部分
```go
// Code generated by protoc-gen-go. DO NOT EDIT.
// source: apply.proto

/*
Package apply is a generated protocol buffer package.

It is generated from these files:
    apply.proto

It has these top-level messages:
    ApplyRequest
    ApplyResponse
*/
package apply

import proto &quot;github.com/golang/protobuf/proto&quot;
import fmt &quot;fmt&quot;
import math &quot;math&quot;

import (
    context &quot;golang.org/x/net/context&quot;
    grpc &quot;google.golang.org/grpc&quot;
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ApplyRequest struct {
    Uid string `protobuf:&quot;bytes,1,opt,name=uid&quot; json:&quot;uid,omitempty&quot;`
}

func (m *ApplyRequest) Reset()                    { *m = ApplyRequest{} }
func (m *ApplyRequest) String() string            { return proto.CompactTextString(m) }
func (*ApplyRequest) ProtoMessage()               {}
func (*ApplyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ApplyRequest) GetUid() string {
    if m != nil {
        return m.Uid
    }
    return &quot;&quot;
}

type ApplyResponse struct {
    Result string `protobuf:&quot;bytes,1,opt,name=result&quot; json:&quot;result,omitempty&quot;`
}

func (m *ApplyResponse) Reset()                    { *m = ApplyResponse{} }
func (m *ApplyResponse) String() string            { return proto.CompactTextString(m) }
func (*ApplyResponse) ProtoMessage()               {}
func (*ApplyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ApplyResponse) GetResult() string {
    if m != nil {
        return m.Result
    }
    return &quot;&quot;
}

func init() {
    proto.RegisterType((*ApplyRequest)(nil), &quot;pluto.services.apply.ApplyRequest&quot;)
    proto.RegisterType((*ApplyResponse)(nil), &quot;pluto.services.apply.ApplyResponse&quot;)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ApplyService service

type ApplyServiceClient interface {
    FetchApplyByUid(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error)
}

type applyServiceClient struct {
    cc *grpc.ClientConn
}

func NewApplyServiceClient(cc *grpc.ClientConn) ApplyServiceClient {
    return &amp;applyServiceClient{cc}
}

func (c *applyServiceClient) FetchApplyByUid(ctx context.Context, in *ApplyRequest, opts ...grpc.CallOption) (*ApplyResponse, error) {
    out := new(ApplyResponse)
    err := grpc.Invoke(ctx, &quot;/pluto.services.apply.ApplyService/FetchApplyByUid&quot;, in, out, c.cc, opts...)
    if err != nil {
        return nil, err
    }
    return out, nil
}

// Server API for ApplyService service

type ApplyServiceServer interface {
    FetchApplyByUid(context.Context, *ApplyRequest) (*ApplyResponse, error)
}

func RegisterApplyServiceServer(s *grpc.Server, srv ApplyServiceServer) {
    s.RegisterService(&amp;_ApplyService_serviceDesc, srv)
}

func _ApplyService_FetchApplyByUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
    in := new(ApplyRequest)
    if err := dec(in); err != nil {
        return nil, err
    }
    if interceptor == nil {
        return srv.(ApplyServiceServer).FetchApplyByUid(ctx, in)
    }
    info := &amp;grpc.UnaryServerInfo{
        Server:     srv,
        FullMethod: &quot;/pluto.services.apply.ApplyService/FetchApplyByUid&quot;,
    }
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {
        return srv.(ApplyServiceServer).FetchApplyByUid(ctx, req.(*ApplyRequest))
    }
    return interceptor(ctx, in, info, handler)
}

var _ApplyService_serviceDesc = grpc.ServiceDesc{
    // 注意这部分代，ServiceName
    // 与之前 PHP 客户端里的生成代码部分 pluto.services.apply.ApplyService
    // 代表了服务的名称，这个名字稍后会用于服务发现服务的注册
    ServiceName: &quot;pluto.services.apply.ApplyService&quot;,
    HandlerType: (*ApplyServiceServer)(nil),
    Methods: []grpc.MethodDesc{
        {
            MethodName: &quot;FetchApplyByUid&quot;,
            Handler:    _ApplyService_FetchApplyByUid_Handler,
        },
    },
    Streams:  []grpc.StreamDesc{},
    Metadata: &quot;apply.proto&quot;,
}

func init() { proto.RegisterFile(&quot;apply.proto&quot;, fileDescriptor0) }

var fileDescriptor0 = []byte{
    // 163 bytes of a gzipped FileDescriptorProto
    0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4e, 0x2c, 0x28, 0xc8,
    0xa9, 0xd4, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x12, 0x29, 0xc8, 0x29, 0x2d, 0xc9, 0xd7, 0x2b,
    0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e, 0x2d, 0xd6, 0x03, 0xcb, 0x29, 0x29, 0x70, 0xf1, 0x38, 0x82,
    0x18, 0x41, 0xa9, 0x85, 0xa5, 0xa9, 0xc5, 0x25, 0x42, 0x02, 0x5c, 0xcc, 0xa5, 0x99, 0x29, 0x12,
    0x8c, 0x0a, 0x8c, 0x1a, 0x9c, 0x41, 0x20, 0xa6, 0x92, 0x3a, 0x17, 0x2f, 0x54, 0x45, 0x71, 0x41,
    0x7e, 0x5e, 0x71, 0xaa, 0x90, 0x18, 0x17, 0x5b, 0x51, 0x6a, 0x71, 0x69, 0x4e, 0x09, 0x54, 0x15,
    0x94, 0x67, 0x94, 0x03, 0x35, 0x2a, 0x18, 0x62, 0x83, 0x50, 0x0c, 0x17, 0xbf, 0x5b, 0x6a, 0x49,
    0x72, 0x06, 0x58, 0xd0, 0xa9, 0x32, 0x34, 0x33, 0x45, 0x48, 0x49, 0x0f, 0x9b, 0x23, 0xf4, 0x90,
    0x5d, 0x20, 0xa5, 0x8c, 0x57, 0x0d, 0xc4, 0x0d, 0x4a, 0x0c, 0x4e, 0xec, 0x51, 0xac, 0x60, 0x89,
    0x24, 0x36, 0xb0, 0xf7, 0x8c, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x1d, 0x1a, 0x00, 0x10, 0xed,
    0x00, 0x00, 0x00,
}
```

服务端代码
```go
// 指定默认端口，可以通过启动命令行修改
// 版本为了编译后查看和服务替换时进行检查
const (
    appListen  = &quot;:9527&quot;
    appVersion = &quot;1.0.0&quot;
    appName    = &quot;Pluto&quot;
)

// 服务可以通过指定配置文件来启动，基础的配置目前还是依赖配置文件
// 服务启动可以指定两个参数：
// -listen=host:port 指定监听端口
// -config=/your/config/path 指定配置文件
// -version 并不会启动服务，只是会输出一些基础数据，用于查看版本等。
var GlobalConfPath string
var GlobalListen string
var GlobalVersion bool

func init() {
    flag.StringVar(&amp;GlobalConfPath, &quot;config&quot;, &quot;./config/config.yaml&quot;, &quot;Config.yaml&quot;)
    flag.StringVar(&amp;GlobalListen, &quot;listen&quot;, appListen, &quot;Host:port&quot;)
    flag.BoolVar(&amp;GlobalVersion, &quot;version&quot;, false, &quot;Version&quot;)
    flag.Parse()

    util.InitConfigure(GlobalConfPath)
}

// 退出系统
func exitApplication() {
    log.Println(&quot;Exit success...&quot;)
    os.Exit(0)
}

func main() {
    log.Println(&quot;Starting...&quot;)

    // 如果参数是 -version 则只是数据配置
    if GlobalVersion {
        fmt.Println(appName, &quot;:&quot;, appVersion)
        fmt.Println(&quot;Listen:&quot;, GlobalListen)
        fmt.Println(&quot;Config:&quot;, GlobalConfPath)
        os.Exit(0)
    }

    // 创建一个信号监听，如果向该服务发送一些信号，对应作出处理，
    // 这里主要是退出服务
    notifySignal := make(chan os.Signal)
    signal.Notify(notifySignal, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGUSR1, syscall.SIGUSR2)
    go func() {
        for signalResult := range notifySignal {
            switch signalResult {
            case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGUSR1, syscall.SIGUSR2:
                exitApplication()
            }
        }
    }()

    log.Println(&quot;Listening....&quot;)

    listen, err := net.Listen(&quot;tcp&quot;, GlobalListen)
    if err != nil {
        log.Fatalf(&quot;Failed to listen: %v&quot;, err)
    }

    // grpc 注册相应的 rpc 服务
    server := grpc.NewServer()
    pb.RegisterApplyServiceServer(server, &amp;service.ApplyService{})
    reflection.Register(server)

    log.Println(&quot;Starting success...&quot;)
    //  开启服务
    if err := server.Serve(listen); err != nil {
        log.Fatalf(&quot;Failed to serve: %v&quot;, err)
    }
}
```
至此，客户端和服务端的代码都完成了，我们部署了 linkerd 和 consul 服务，所以需要我们注册服务到 consul 上，之后我们就可以通过 **127.0.0.1:4141** 端口来调用了，当然直接调用服务的 **9527** 端口也是没问题的，但是我们是集群服务，避免单点，所以需要把服务注册到 consul 上。注册服务我们可以通过代码也可以通过我们的界面管理，因为我们有统一的 webUI 管理界面，所以我们直接通过 webUI 的界面来注册。注册服务的时候有一个非常重要的字段 ServiceName，就是我们前文两次提到的那个名字，只有通过这个名字，服务端和客户端才能通过 linkerd 的代理服务建立起链接。而这一切 linkerd 和 consul 都为我们做好了，我们只需要将服务注册上去即可。

![服务注册](/assets/images/consul_apply_service.png)


PS: 由于咱们墙大，所以 golang 的很多包无法下载，没有代理的话，可以通过 glide mirror 功能设置镜像，大部分 google 域名下的包在 github 都有镜像，可以顺利下载。这个功能太好用了，再补充一个 glidle.yaml 的配置文件内容吧。

```yaml
import:
- package: github.com/golang/protobuf
  version: ^1.0.0
  subpackages:
  - proto
- package: golang.org/x/net
  subpackages:
  - context
- package: golang.org/x/text
  subpackages:
  - unicode
  - secure
- package: google.golang.org/grpc
  subpackages:
  - reflection
- package: google.golang.org/genproto
  subpackages:
  - rpc/status
  - googleapis
- package: google.golang.org/appengine
  subpackages:
  - cloudsql
- package: github.com/olivere/elastic
  version: ^2.0.60
- package: github.com/jmoiron/sqlx
- package: github.com/bradfitz/gomemcache
  subpackages:
  - memcache
- package: golang.org/x/lint
- package: github.com/jinzhu/configor
- package: github.com/BurntSushi/toml
  version: ^0.3.0
```

下面是 .glidle/mirrors.yaml 配置
```yaml
repos:
- original: https://golang.org/x/crypto
  repo: https://github.com/golang/crypto
- original: https://golang.org/x/lint
  repo: https://github.com/golang/lint
- original: https://golang.org/x/net
  repo: https://github.com/golang/net
- original: https://golang.org/x/sys
  repo: https://github.com/golang/sys
- original: https://golang.org/x/text
  repo: https://github.com/golang/text
- original: https://google.golang.org/appengine
  repo: https://github.com/golang/appengine
- original: https://google.golang.org/genproto
  repo: https://github.com/google/go-genproto
- original: https://google.golang.org/grpc
  repo: https://github.com/grpc/grpc-go
```
EOT;</content><author><name></name></author><summary type="html">为什么是实践应用（1）？因为每一个软件都有很多事儿，稍后我们会拆分章节分到每一期去整理和讲解。</summary></entry><entry><title type="html">MySQL 慢查询优化案例（1）</title><link href="http://rust.love/mysql/explain/slow/2018/03/27/mysql-slow-opt.html" rel="alternate" type="text/html" title="MySQL 慢查询优化案例（1）" /><published>2018-03-27T00:00:00+08:00</published><updated>2018-03-27T00:00:00+08:00</updated><id>http://rust.love/mysql/explain/slow/2018/03/27/mysql-slow-opt</id><content type="html" xml:base="http://rust.love/mysql/explain/slow/2018/03/27/mysql-slow-opt.html">问题描述：

&gt; SQL 慢查询，在我们给 x 度做输出抓取的时候，需要扫描全部的帖子，把帖子数据生成固定的格式（XML 文件）让 x 度来抓取。目前 DBA 那边有一个慢查询，大约每天 5000 次执行，查询语句如下：

```sql
select * from `jz_post` where `id` &gt; '{x}' and (`st` = '5') order by `id` asc limit 500
```

这个语句的目的就是取固定状态下所有的帖子，按照 id 分批取，id 是主键，st 也有索引。该语句从 Explain 上看，是使用到索引了，但是 order by 引起性能问题，我们是循环批量取数据，为了保证数据的完整不被遗漏，所以需要 order by，Explain 如下图所示：

![Explain](/assets/images/sql1.png)

这个查询语句虽然用了索引，但是速度还是会非常慢，因为总体数据量大，id 和 st 都是有索引的，如果只是通过 id 和 st 索引，根本解决不了问题，采取的优化手段就是拆分查询，将获取数据分为两部分：

- select id from jz_post where id &gt; '{x}' and st = 5 order by id asc limit 500;
- select * from jz_post where id in ('上一次查询 ID 的结果')

看下 Explain 结果：

![Explain](/assets/images/sql2.png)

从影响的数据行上来看第一次查询 id 已经不存在性能问题了，一定量的 id 取数据也不会有性能问题，带来的后果就是程序里需要单独去再次查询结果集，但是不会影响整个数据库。

EOF;</content><author><name></name></author><summary type="html">问题描述：</summary></entry><entry><title type="html">通过项目来学习 Golang 之 cron.v2 源码分析（一周学习报-第 6 期）</title><link href="http://rust.love/cron.v2/golang/chan/timer/2018/03/23/go-cron-v2.html" rel="alternate" type="text/html" title="通过项目来学习 Golang 之 cron.v2 源码分析（一周学习报-第 6 期）" /><published>2018-03-23T00:00:00+08:00</published><updated>2018-03-23T00:00:00+08:00</updated><id>http://rust.love/cron.v2/golang/chan/timer/2018/03/23/go-cron-v2</id><content type="html" xml:base="http://rust.love/cron.v2/golang/chan/timer/2018/03/23/go-cron-v2.html">根据[第五期](http://rust.love/golang/gin-gonic/crontab/2018/03/09/golang-crontab-web.html)的 cron 项目，理解 cron.v2 项目的源码，主要涉及的知识点

- go 关键字
- chan select
- 闭包
- 接口

先看下源码的结构

```shell
├── LICENSE
├── README.md
├── constantdelay.go 处理特殊时间格式 struct
├── cron.go 负责整个流程控制和调度的 struct
├── doc.go 文档文件
├── parser.go 将输入的 crontab 格式进行转换
└── spec.go Schedule 数据定义和转换
```

整个代码的执行流程
```shell
        NewCron()
          ⇊
Add(Schedule, Command)
          ⇊
    Parse(Schedule)
          ⇊
         Run()
```

主要的相关的源码 ***cron.go***
```go
type Cron struct {
    entries  []*Entry // 一个任务，就是一个 entry
    stop     chan struct{} // 停止任务
    add      chan *Entry // 添加任务
    remove   chan EntryID // 移除任务，每个 Entry 都有一个 ID，稍后介绍
    snapshot chan []Entry // 当前任务
    running  bool // 整个 Cron 是否处于运行状态
    nextID   EntryID // 下一个 Entry
}

// 一个具体的任务
type Entry struct {
    // ID is the cron-assigned ID of this entry, which may be used to look up a
    // snapshot or remove it.
    ID EntryID

    // Schedule on which this job should be run.
    Schedule Schedule

    // Next time the job will run, or the zero time if Cron has not been
    // started or this entry's schedule is unsatisfiable
    Next time.Time

    // Prev is the last time this job was run, or the zero time if never.
    Prev time.Time

    // Job is the thing to run when the Schedule is activated.
    Job Job
}
```

上面的 Entry 里面有两个 struct，我们先来看一下 ***Schedule***，Schedule 是一个 interface，主要是描述了一个 Job 具体运行的时间
```go
// 一个接口
// Schedule describes a job's duty cycle.
type Schedule interface {
    // Next returns the next activation time, later than the given time.
    // Next is invoked initially, and then each time the job is run.
    Next(time.Time) time.Time
}
```

Golang 的接口和其它面向对象语言有所不同，接口和具体实现类不是一个强关联，如上面 Schedule 定义了一个方法 Next，那么任何一个实现了该方法的 struct 都相当于实现了这个接口，如代码中 SpecSchedule 这个 struct，我们可以说他实现了 Schedule 那个接口。如果是一个空接口，没有任何方法，那么所有的 struct 都实现了这个空接口。

```go
// SpecSchedule specifies a duty cycle (to the second granularity), based on a
// traditional crontab specification. It is computed initially and stored as bit sets.
type SpecSchedule struct {
    Second, Minute, Hour, Dom, Month, Dow uint64
    Location                              *time.Location
}

// Next returns the next time this schedule is activated, greater than the given
// time.  If no time can be found to satisfy the schedule, return the zero time.
func (s *SpecSchedule) Next(t time.Time) time.Time {
    // 此处代码省略
}
```

我们真正加入到 Entry 的 Schedule 都是 SpecSchedule，SpecSchedule 的 Next 方法主要是处理下一次 Job 运行时间的方法，该方法里还使用了 goto 关键字，在 Parse 阶段调用的 Parse() 方法将 crontab 格式的数据转换为 SpecSchedule 的实例。

```go
WRAP:
    if t.Year() &gt; yearLimit {
        return time.Time{}
    }

    // Find the first applicable month.
    // If it's this month, then do nothing.
    for 1&lt;&lt;uint(t.Month())&amp;s.Month == 0 {
        // If we have to add a month, reset the other parts to 0.
        if !added {
            added = true
            // Otherwise, set the date at the beginning (since the current time is irrelevant).
            t = time.Date(t.Year(), t.Month(), 1, 0, 0, 0, 0, s.Location)
        }
        t = t.AddDate(0, 1, 0)

        // Wrapped around.
        if t.Month() == time.January {
            goto WRAP
        }
    }
```

goto 关键字是 Golang 控制流程的关键字之一，用起来比较简单，就是在函数某个位置写个标签，后续流程里 goto 到这个标签，跟 C 语言里的 goto 类似。

接下来我们来说一说闭包，闭包这个概念大家多少都有些理解了，结合 cron.v2 的代码，我们来看一看

```go
// FuncJob is a wrapper that turns a func() into a cron.Job
type FuncJob func() // FuncJob 是一个函数类型，好比 type EntryId int

func (f FuncJob) Run() { f() } // 给 FuncJob 增加了一个 Run 方法

// AddFunc adds a func to the Cron to be run on the given schedule.
// spec 就是 crontab 类似的时间格式 */1 * * * 1 或者 @every 5s 这类的
// cmd 这里传进来就是函数例如 AddFunc(&quot;@every 1s&quot;, func () { fmt.Println(&quot;Hello Func&quot;) })
func (c *Cron) AddFunc(spec string, cmd func()) (EntryID, error) {
    return c.AddJob(spec, FuncJob(cmd))
}
```

看下这个例子
```go
package main

import &quot;fmt&quot;

type FFF func()

func (f FFF) printFFF() {
    f()
    fmt.Println(&quot;printFFF&quot;)
}
func main() {
    fp := FFF(func() {
        fmt.Println(&quot;YoYoYo&quot;)
    })
    fp.printFFF()
    fmt.Println(&quot;hello&quot;)
}
// 结果
// YoYoYo
// printFFF
// hello
```

接下来我们来看看 Run 部分的 ***go*** 关键字和 ***chan***，这两个关键字可以说是 Golang 语言的精华所在了。***go*** 关键字主要是用来创建一个 ***goroutine***（协程），而 ***goroutine*** 和 ***chan*** 协作使用，来完成不同 ***goroutine*** 之间的通信。先看一个例子：

```go
package main

import &quot;fmt&quot;
import &quot;time&quot;

func main() {
    var amChan chan int
    fmt.Println(&quot;来通个信&quot;)
    amChan = make(chan int, 5)
    for i := 0; i &lt; 5; i++ {
        // 注释1 go func() {
            amChan &lt;- i

        // 注释1 }()
        // 注释2 time.Sleep(100 * time.Millisecond)
    }
    for i := 0; i &lt; 5; i++ {
        result := &lt;-amChan
        fmt.Println(result)
    }
}
```
上面的代码，如果`注释 1 和 2`部分不打开，输出结果 `0 1 2 3 4`，如果只是打开`注释 1`，我们看到的结果会是 `5 5 5 5 5`，如果`注释 1 和 2`两部分都打开，则会输出 `0 1 2 3 4`。

chan 在我理解起来更像是一个队列，输入数据，取出数据，这里面 `注释 1 和 2` 带来不同的输出结果主要是因为 go 这个关键字开启协程导致的，协程是独立的处理单元，你无法知道他们什么时候真正的启动执行，而注释带来的就是代码逻辑顺序依赖变量 `i`，执行整个 for 循环以后，可能 go 的协程才执行，这样必然带来输出结果不一致的问题。下面我们看下 Cron.Run 方法调用的代码：

```go
// Start the cron scheduler in its own go-routine.
func (c *Cron) Start() {
    c.running = true // 设置状态
    go c.run() // 通过协程来执行 run()
}

// run the scheduler.. this is private just due to the need to synchronize
// access to the 'running' state variable.
func (c *Cron) run() {
    // Figure out the next activation times for each entry.
    now := time.Now().Local()
    // 设置下次执行时间
    for _, entry := range c.entries {
        entry.Next = entry.Schedule.Next(now)
    }

    for {
        // Determine the next entry to run.
        // 排序当前任务的执行时间，排序方法见下面代码
        sort.Sort(byTime(c.entries))

        // effective 就是下次任务要执行的时间
        var effective time.Time
        if len(c.entries) == 0 || c.entries[0].Next.IsZero() {
            // 此处是任务为空时处理逻辑
            // If there are no entries yet, just sleep - it still handles new entries
            // and stop requests.
            effective = now.AddDate(10, 0, 0)
        } else {
            effective = c.entries[0].Next
        }
        // Golang 针对 chan 的读写操作，提供了 select 语句，
        // 可以用 select 来检测或者阻塞 chan 操作的，
        // select 会评估 case 语句块，只要有任何一个评估通过，
        // 就会执行对应的语句，如果都无法通过评估，
        // 则会一直阻塞，直到有语句可以评估通过。
        // 如果都无法通过评估且语句有 `default` 块，则执行 `default` 部分
        select {
            case now = &lt;-time.After(effective.Sub(now)):
                // Run every entry whose next time was this effective time.
                for _, e := range c.entries {
                    if e.Next != effective {
                        break
                    }
                    go e.Job.Run()
                    e.Prev = e.Next
                    e.Next = e.Schedule.Next(effective)
                }
                continue

            case newEntry := &lt;-c.add:
                c.entries = append(c.entries, newEntry)
                newEntry.Next = newEntry.Schedule.Next(now)

            case &lt;-c.snapshot:
                c.snapshot &lt;- c.entrySnapshot()

            case id := &lt;-c.remove:
                c.removeEntry(id)

            case &lt;-c.stop:
                return
        }

        now = time.Now().Local()
    }
}
```

整个 Cron 运行的时候，就是个无限循环，不停的循环 `Cron.entries`，每次循环一个 Entry 任务出来，并计算该任务下次的执行时间，在循环 `entries` 前对其排序，将最近要执行的任务取出来进行和当前时间对比，反复如此，下面就是排序相关代码 `sort.Sort(byTime(c.entries))`

```go
type byTime []*Entry

func (s byTime) Len() int      { return len(s) }
func (s byTime) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
func (s byTime) Less(i, j int) bool {
    // Two zero times should return false.
    // Otherwise, zero is &quot;greater&quot; than any other time.
    // (To sort it at the end of the list.)
    if s[i].Next.IsZero() {
        return false
    }
    if s[j].Next.IsZero() {
        return true
    }
    return s[i].Next.Before(s[j].Next)
}
```

EOF;</content><author><name></name></author><summary type="html">根据第五期的 cron 项目，理解 cron.v2 项目的源码，主要涉及的知识点</summary></entry></feed>